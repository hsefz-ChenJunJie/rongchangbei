# AI 对话应用前端开发文档

## 概述

本文档为 AI 对话应用的前端开发指南。系统通过 WebSocket 与后端实时通信，支持语音输入、智能对话生成和用户反馈处理。

## 界面设计和状态管理

### 对话页面状态
- **空闲状态**：等待用户开始新消息或手动触发生成回答
- **录制消息中**：显示录音动画和结束消息按钮
- **处理语音转文字中**：显示处理状态，禁用交互
- **生成意见建议中**：自动生成意见关键词，可以手动触发打断
- **生成回答建议中**：手动触发的回答生成，显示加载状态
- 任何时候都可以修改对话情景和建议回答数量。

## 核心功能循环

### 完整对话流程

#### 阶段 1：对话初始化
1. 用户在主界面选择预定的对话，点击"开始对话"按钮；或者选择开始临时对话。
2. 前端发送对话开始事件到后端（如果是恢复之前的对话，需包含历史消息）
3. 后端记录历史消息并自动触发意见生成（如果有历史消息或情景描述）
4. 界面切换到录音状态

#### 阶段 2：消息录制和处理
1. 用户点击"开始新消息"按钮，输入发送者标识（如自己的姓名）
2. 前端发送消息开始事件到后端
3. 前端持续发送音频流到后端
4. 用户点击"结束消息"按钮
5. 前端发送消息结束事件
6. 后端完成语音转文字，返回消息记录确认（包含消息ID和内容）

#### 阶段 3：自动意见生成
1. 消息记录后，后端自动生成意见倾向关键词
2. 前端接收并显示意见建议
3. 用户可以在此期间手动触发回答生成（会中断意见生成）

#### 阶段 4：手动回答生成和处理
1. 用户选择要关注的消息（可选）
2. 用户输入意见倾向（可选）
3. 用户点击"生成回答"按钮
4. 前端发送手动触发生成事件
5. 接收后端返回的多个AI回答建议
6. 在界面展示所有回答选项
7. 用户从中选择满意的回答
8. 将选中回答发送给后端记录为新消息
9. 将选中回答转换为语音播放

#### 阶段 5：对话继续或结束
- 继续对话：返回阶段 2，开始新消息录制
- 结束对话：发送结束事件，清理界面状态

### 重要注意事项

- **会话ID管理**：每个对话都有唯一ID，前端需要在所有事件中携带此ID
- **消息ID管理**：每条消息都有唯一ID，用于引用和聚焦消息
- **状态管理**：对话状态包括："idle"、"recording_message"、"processing_stt"、"generating_opinions"、"generating_response"
- **音频处理**：音频数据需要 base64 编码后发送
- **消息流程**：必须先发送消息开始事件再发送音频流
- **优先级处理**：手动触发的回答生成会中断自动的意见生成
- **修改建议即时处理**：用户发送修改建议后立即触发新的回答生成
- **选择回答记录**：用户选择的LLM回答必须发送给后端记录

## WebSocket 事件通信

### 连接地址
使用 ws 协议，端口为 8000

### 事件字段规范说明
所有WebSocket事件都遵循必需和可选字段规范：
- **[必需]** 字段：必须包含，不能为空或null
- **[可选]** 字段：可以省略，或设置为空值
- 字段验证失败将返回错误事件
- session_id在对话开始事件中不需要，其他事件均为必需

### 前端发送的事件

#### 对话开始
```json
{
  "type": "conversation_start", // [必需]
  "data": {
    "scenario_description": "对话情景描述文本", // [可选] 
    "response_count": 3, // [必需] 1-5之间的整数
    "history_messages": [ // [可选] 之前会话中记录的所有消息
      {
        "sender": "用户姓名", // [必需] 消息发送者标识
        "content": "消息内容" // [必需] 消息内容
      }
    ]
  }
}
```

#### 消息开始
```json
{
  "type": "message_start", // [必需]
  "data": {
    "session_id": "会话唯一ID", // [必需] 会话创建后获得
    "sender": "消息发送者标识" // [必需] 消息发送者（如用户姓名、角色等）
  }
}
```

#### 音频流
```json
{
  "type": "audio_stream", // [必需]
  "data": {
    "session_id": "会话唯一ID", // [必需] 会话创建后获得
    "audio_chunk": "base64编码的音频数据" // [必需] 音频数据块
  }
}
```

#### 消息结束
```json
{
  "type": "message_end", // [必需]
  "data": {
    "session_id": "会话ID" // [必需] 目标会话标识
  }
}
```

#### 手动触发生成回答
```json
{
  "type": "manual_generate", // [必需]
  "data": {
    "session_id": "会话ID", // [必需]
    "focused_message_ids": ["msg_001", "msg_003"], // [可选] 用户选择聚焦的消息ID数组
    "user_opinion": "用户意见倾向文本" // [可选] 用户的意见倾向
  }
}
```

#### 用户选择回答
```json
{
  "type": "user_selected_response", // [必需]
  "data": {
    "session_id": "会话ID", // [必需]
    "selected_content": "用户选择的回答内容", // [必需] 用户选择的LLM回答
    "sender": "用户标识" // [必需] 消息发送者（即用户自己）
  }
}
```

#### 对话结束
```json
{
  "type": "conversation_end", // [必需]
  "data": {
    "session_id": "会话ID" // [必需]
  }
}
```

#### 用户反馈
- 修改建议：
```json
{
  "type": "user_modification", // [必需]
  "data": {
    "session_id": "会话ID", // [必需]
    "modification": "修改建议文本" // [必需] 对AI回复的修改意见
  }
}
```
- 补充情景：
```json
{
  "type": "scenario_supplement", // [必需]
  "data": {
    "session_id": "会话ID", // [必需]
    "supplement": "补充情景描述" // [必需] 补充的对话情景信息
  }
}
```
- 修改回答数量：
```json
{
  "type": "response_count_update", // [必需]
  "data": {
    "session_id": "会话ID", // [必需]
    "response_count": 4 // [必需] 新的建议回答数量，1-5之间的整数
  }
}
```

### 后端返回的事件

#### 会话创建确认
```json
{
  "type": "session_created", // [必需]
  "data": {
    "session_id": "生成的唯一会话ID" // [必需] 后续所有操作需要此ID
  }
}
```

#### 消息记录确认
```json
{
  "type": "message_recorded", // [必需]
  "data": {
    "session_id": "会话ID", // [必需]
    "message_id": "消息唯一ID", // [必需] 分配给消息的ID
    "content": "转录或选择的消息内容", // [必需] 消息的文字内容
    "sender": "消息发送者" // [必需] 消息发送者标识
  }
}
```

#### 意见建议
```json
{
  "type": "opinion_suggestions", // [必需]
  "data": {
    "session_id": "会话ID", // [必需]
    "suggestions": ["意见关键词1", "意见关键词2", "意见关键词3"], // [必需] 生成的意见倾向关键词
    "request_id": "请求唯一标识" // [可选] 用于请求追踪
  }
}
```

#### AI回答建议
```json
{
  "type": "llm_response", // [必需]
  "data": {
    "session_id": "会话ID", // [必需]
    "suggestions": ["建议回答1", "建议回答2", "建议回答3"], // [必需] 回答建议数组
    "request_id": "请求唯一标识" // [可选] 用于请求追踪
  }
}
```

#### 状态更新
```json
{
  "type": "status_update", // [必需]
  "data": {
    "session_id": "会话ID", // [必需]
    "status": "idle|recording_message|processing_stt|generating_opinions|generating_response", // [必需] 会话状态
    "message": "状态描述" // [可选] 状态的文字描述
  }
}
```
**状态说明：**
- `idle`：空闲状态，等待新消息或手动触发
- `recording_message`：正在录制消息中
- `processing_stt`：处理语音转文字中
- `generating_opinions`：自动生成意见建议中
- `generating_response`：手动触发的回答生成中

#### 错误信息
```json
{
  "type": "error", // [必需]
  "data": {
    "session_id": "会话ID", // [可选] 会话相关错误才包含
    "error_code": "错误代码", // [必需] 标准化错误代码
    "message": "错误描述", // [必需] 用户友好的错误描述
    "details": "详细错误信息" // [可选] 调试用的详细信息
  }
}
```

## 音频处理要求

### 录制参数
- 采样率：16000 Hz
- 声道：单声道
- 格式：建议 webm/opus
- 发送间隔：100ms

### 处理流程
1. 申请麦克风权限
2. 创建 MediaRecorder 实例
3. 定期收集音频数据块
4. 转换为 base64 格式
5. 通过 WebSocket 发送

### 语音播放
自行选择本地 tts 完成播放。

## 错误处理

### 重连机制
WebSocket 连接断开时，自动尝试重连（最多 5 次，间隔递增）。